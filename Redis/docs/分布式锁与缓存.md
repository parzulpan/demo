# 分布式锁与缓存

## 缓存

### 缓存使用

为了系统性能的提升，一般都会将部分数据放入缓存中，加速访问。而 db 承担数据落盘工作。

**哪些数据适合放入缓存？**

* **即时性、数据一致性要求不高的**
* **访问量大且更新频率不高的(读多，写少)**

**举例**：电商类应用，商品分类，商品列表等适合缓存并加一个失效时间(根据数据更新频率来定)，后台如果发布一个商品，买家需要 5 分钟才能看到新的商品一般还是可以接受的。

**伪代码逻辑**：

```java
data = cache.load(id);	// 从缓存加载数据
if(data == null){
    data = db.loadid);	// 从数据库加载数据
    cache.put(id，data);	// 保存到 cache 中
}
// 中间可能还涉及到格式的转换
retum data;
```

**注意**：在开发中，凡是放入缓存中的数据都应该**指定过期时间**，使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致的问题。

缓存的使用分类：

* 本地缓存。适用于单体应用，但是在分布式模式下存在缓存一致性问题、拓展性问题和高可用问题。
* 分布式缓存。可以很好的解决本地缓存的问题。

### 整合 Redis 作为缓存

[Docker 安装 Redis 参考链接](https://www.cnblogs.com/parzulpan/p/14260911.html#%E5%AE%89%E8%A3%85-docker)

[SpringBoot 整合 Redis 参考链接](https://www.cnblogs.com/parzulpan/p/14220685.html)

## 缓存失效问题

### 缓存穿透

**缓存穿透**：指查询一个一定不存在的数据，由于缓存不命中，将会去查询数据库，但是数据库也没有此数据，并且也没有将查询的空结果存入缓存中，这将导致这个不存在的数据每次请求都会到数据库中去查询，失去了缓存的意义。

**风险**：利用不存在的数据进行攻击，数据库瞬时压力增大，最终导致崩溃。

**解决方案**：

* 缓存空结果；
* 布隆过滤器；
* MVC 拦截器；

### 缓存雪崩

**缓存雪崩**：指在设置缓存时 key 采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到了数据库。

**风险**：数据库瞬时压力过大导致崩溃。

**解决方案**：

* 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生；
* 如果缓存数据库是**分布式部署**，最好将热点数据均匀分布在不同缓存数据库中；

出现雪崩，常用的手段是降级熔断：

* 事前：尽量保证整个 Redis 集群的高可用性，发现机器宕机尽快补上，并且选择合适的内存淘汰策略；
* 事中：本地缓存 + Sentinel 降级熔断，避免数据库崩溃；
* 事后：利用 Redis 持久化机制，将保存的数据恢复缓存；

### 缓存击穿

**缓存击穿**：指一些 “热点” 数据在大量请求同时访问前刚好失效，那么就会同时去数据库中查询。

**风险**：数据库瞬时压力过大导致崩溃。

**解决方案**：

* 设置 “热点” 数据永不过期；
* 加互斥锁（简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去数据库加载，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行数据库加载的操作并回设缓存；否则，就重试整个 get 缓存的方法。）；

## 缓存数据一致性

### 双写模式



### 失效模式



### 解决方案



### 解决方案-Canal



## 分布式锁

### 分布式下如何加锁

一个本地锁的例子：假设有一个商品服务，每一个服务都部署在一个独立的 tomcat 中，每一个服务中都使用一个锁。假设目前有 8 个服务，则需要加 8 把锁，且这 8 把锁相互独立。

但是本地锁，只能锁住当前进程，所以需要分布式锁。

### 锁的时序问题

在加锁的时候，需要将**查询缓存**和**查询数据库**这两步同时放在加锁的方法（或者加锁的代码块）中，但是这样会出现一个问题，即多次查询数据库。这是因为，第一个查询数据库时，由于设置缓存也需要时间，此时数据还没有放入缓存中。这段时间内，缓存中还没有数据，就有可能导致多次查询数据库。所以需要将**设置缓存**也放在锁中。

![锁的时序问题](https://images.cnblogs.com/cnblogs_com/parzulpan/1909162/o_210415084743%E9%94%81%E7%9A%84%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98.png)

### 分布式锁的演进和基本原理

由于本地锁只能锁住当前进程，如果我们在进行秒杀活动或者说抢优惠券活动的时候，如果只剩了1件商品或者1张优惠券，如果使用的是本地锁，同时多个服务一块请求获取数据，就有可能产生“超卖”的现象，为了避免这种情况的发生，我们就需要使用分布式锁。

我们可以同时去一个地方“占坑（加锁）”，如果占到，就执行逻辑。否则就必须等待，直到释放锁。“占坑（加锁）”可以去 redis，也可以去数据库，可以去任何服务都能访问的地。如果没有获取到锁，则可以可以以**自旋**的方式进行等待。

#### 分布式锁演进-V1

```java
/**
     * 从数据库获取数据，使用 redis 的分布式锁 V1
     * 问题：
     *  1、setnx 占好了位，业务代码异常或者程序在页面过程中宕机。没有执行删除锁逻辑，这就造成了死锁
     * 解决：
     *  设置锁的自动过期，即使没有删除，会自动删除
     */
public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithRedisLockV1() {
    // Redis 命令：set lock 1 NX
    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent("lock", "1");
    if ( lock ) {
        // 加锁成功，执行业务
        Map<String, List<Catelog2Vo>> dataFromDb = getDataFromDb();
        // 删除锁
        stringRedisTemplate.delete("lock");
        return dataFromDb;
    } else {
        // 加锁失败，重试
        // 休眠 100ms 重试
        // 自旋的方式
        return getCatalogJsonFromDbWithRedisLockV1();
    }
}
```



![分布式锁演进-V1](https://images.cnblogs.com/cnblogs_com/parzulpan/1909162/o_210415124242%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BC%94%E8%BF%9B-V1.jpg)

<center>图片参考自 CSDN [runewbie](https://blog.csdn.net/runewbie)</center>

#### 分布式锁演进-V2

```java
/**
     * 从数据库获取数据，使用 redis 的分布式锁 V2
     * 问题：
     *  1、setnx 设置好，正要去设置过期时间，结果突然断电，服务宕机。又死锁了。
     * 解决：
     *  设置过期时间和占位必须是原子的。redis支持使用 setnx ex 命令。
     */
public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithRedisLockV2() {
    // Redis 命令：set lock 1 NX
    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent("lock", "1");
    if ( lock ) {
        // 加锁成功，执行业务
        // 设置过期时间
        stringRedisTemplate.expire("lock", 30, TimeUnit.SECONDS);
        Map<String, List<Catelog2Vo>> dataFromDb = getDataFromDb();
        // 删除锁
        stringRedisTemplate.delete("lock");
        return dataFromDb;
    } else {
        // 加锁失败，重试
        // 休眠 100ms 重试
        // 自旋的方式
        return getCatalogJsonFromDbWithRedisLockV2();
    }
}
```



![分布式锁演进-V2](https://images.cnblogs.com/cnblogs_com/parzulpan/1909162/o_210415124250%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BC%94%E8%BF%9B-V2.jpg)

<center>图片参考自 CSDN [runewbie](https://blog.csdn.net/runewbie)</center>

#### 分布式锁演进-V3

```java
/**
     * 从数据库获取数据，使用 redis 的分布式锁 V3
     * 问题：
     *  1、如果由于业务时间很长，锁自己过期了，我们直接删除，有可能把别人正在持有的锁删除了。
     * 解决：
     *  占锁的时候，值指定为 uuid，每个人匹配是自己的锁才删除。
     */
public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithRedisLockV3() {
    // Redis 命令：set lock 1 EX 30 NX
    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent("lock", "1", 30, TimeUnit.SECONDS);
    if ( lock ) {
        // 加锁成功，执行业务
        Map<String, List<Catelog2Vo>> dataFromDb = getDataFromDb();
        // 删除锁
        stringRedisTemplate.delete("lock");
        return dataFromDb;
    } else {
        // 加锁失败，重试
        // 休眠 100ms 重试
        // 自旋的方式
        return getCatalogJsonFromDbWithRedisLockV3();
    }
}
```



![分布式锁演进-V3](https://images.cnblogs.com/cnblogs_com/parzulpan/1909162/o_210415124259%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BC%94%E8%BF%9B-V3.jpg)

<center>图片参考自 CSDN [runewbie](https://blog.csdn.net/runewbie)</center>

#### 分布式锁演进-V4

```java
/**
     * 从数据库获取数据，使用 redis 的分布式锁 V4
     * 问题：
     *  1、如果正好判断是当前值，正要删除锁的时候，锁已经过期，别人已经设置到了新的值。那么我们删除的是别人的锁。
     * 解决：
     *  删除锁必须是原子性的。使用 redis+Lua脚本完成。
     */
public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithRedisLockV4() {
    // Redis 命令：set lock uuid EX 30 NX
    String uuid = UUID.randomUUID().toString();
    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent("lock", uuid, 30, TimeUnit.SECONDS);
    if ( lock ) {
        // 加锁成功，执行业务
        Map<String, List<Catelog2Vo>> dataFromDb = getDataFromDb();
        // 删除锁前先进行获取，判断是不是自己的锁编号 uuid，是的话再删除
        String lockValue = stringRedisTemplate.opsForValue().get("lock");
        if (uuid.equals(lockValue)) {
            stringRedisTemplate.delete("lock");
        }
        return dataFromDb;
    } else {
        // 加锁失败，重试
        // 休眠 100ms 重试
        // 自旋的方式
        return getCatalogJsonFromDbWithRedisLockV4();
    }
}
```



![分布式锁演进-V4](https://images.cnblogs.com/cnblogs_com/parzulpan/1909162/o_210415124312%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BC%94%E8%BF%9B-V4.jpg)

<center>图片参考自 CSDN [runewbie](https://blog.csdn.net/runewbie)</center>

#### 分布式锁演进-V5

```java
/**
     * 从数据库获取数据，使用 redis 的分布式锁 V5
     * 问题：
     *  1、锁的自动续期问题；
     *  2、操作太麻烦，加锁解锁都需要自己完成，如果有很多锁则需要写很多重复的代码。
     * 解决：
     *  使用封装好的 redis 分布式锁工具类，例如 Redisson
     */
public Map<String, List<Catelog2Vo>> getCatalogJsonFromDbWithRedisLockV5() {
    // Redis 命令：set lock uuid EX 30 NX
    String uuid = UUID.randomUUID().toString();
    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent("lock", uuid, 30, TimeUnit.SECONDS);
    if ( lock ) {
        log.debug("获取分布式锁成功....");
        Map<String, List<Catelog2Vo>> dataFromDb;
        try {
            //加锁成功，执行业务
            dataFromDb = getDataFromDb();
        } finally {
            //删除锁前先进行获取，判断是不是自己的锁编号uuid，是的话再删除
            //获取对比值+对比成功删除==原子操作  使用lua脚本解锁
            String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
            //删除锁，删除成功返回 1，删除失败返回 0
            Long lock1 = stringRedisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class),
                                                     Arrays.asList("lock"), uuid);
        }
        return dataFromDb;
    } else {
        log.debug("获取分布式锁失败，等待重试....");
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 加锁失败，重试
        // 休眠 100ms 重试
        // 自旋的方式
        return getCatalogJsonFromDbWithRedisLockV5();
    }
}
```



![分布式锁演进-V5](https://images.cnblogs.com/cnblogs_com/parzulpan/1909162/o_210415124320%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BC%94%E8%BF%9B-V5.jpg)

<center>图片参考自 CSDN [runewbie](https://blog.csdn.net/runewbie)</center>



### Redisson 的使用和整合



## SpringCache

### 简介



### 基础概念



### SpringCache 整合



### 自定义缓存配置



### 缓存穿透问题解决



### SpringCache 的不足



## 总结



